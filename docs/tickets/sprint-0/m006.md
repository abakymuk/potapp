S-01.6 — Realtime Channels

Goal: канал orders:tenant:<id>; события по таблице orders доставляются подписчикам.
AC: вставка в orders транслируется всем авторизованным клиентам того же tenant_id.

⸻

Scope
• In: включить репликацию orders в публикации supabase_realtime, настроить идентичность, подписку в web (hook/утилита), смоки.
• Out: SSE/фоллбеки, UI-доски — отдельные тикеты (см. S-05.x).

AC (Gherkin)
• Given пользователь A состоит в tenant T1
When создаётся запись в public.orders с tenant_id=T1
Then клиент A, подписанный на orders:tenant:T1, получает событие INSERT.
• Given пользователь B из tenant T2
When создаётся запись в public.orders с tenant_id=T1
Then клиент B не получает событие (RLS/фильтр).

DoD
• Таблица orders добавлена в публикацию supabase_realtime (+ REPLICA IDENTITY FULL)
• Клиентская утилита subscribeOrders(tenantId, handler) в packages/lib
• Демо-страница/скрипт подписки (apps/web/app/realtime-demo)
• Смоки: вставка в orders → событие приходит подписчикам того же tenant
• Док: /docs/notes/realtime-channels.md

⸻

Микротикеты (атомарные шаги)

S-01.6.a — SQL: публикация и идентичность

Создай миграцию supabase/migrations/<ts>\_realtime_orders.sql:

-- Для корректной передачи old/new значений при UPDATE
alter table public.orders replica identity full;

-- Добавить таблицу в публикацию (идемпотентно)
do $$
begin
  if not exists (
    select 1 from pg_publication_tables
    where pubname = 'supabase_realtime' and schemaname='public' and tablename='orders'
  ) then
    alter publication supabase_realtime add table public.orders;
  end if;
end $$;

Проверь:

select \* from pg_publication_tables where pubname='supabase_realtime' and tablename='orders';

S-01.6.b — Индекс и RLS-предпосылки

(у нас уже есть индекс по tenant_id, см. S-01.2)

create index if not exists idx_orders_tenant on public.orders(tenant_id);

Политики из S-01.3 уже ограничивают доступ по tenant_id. Realtime учитывает RLS при доставке.

S-01.6.c — Клиентская утилита подписки

packages/lib/src/realtime/orders.ts:

import { createClient, RealtimeChannel } from '@supabase/supabase-js'

export type OrderChange = {
type: 'INSERT' | 'UPDATE' | 'DELETE'
new: any
old: any
}

export function createSupabaseAnon() {
const url = process.env.NEXT_PUBLIC_SUPABASE_URL!
const key = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
return createClient(url, key)
}

/\*_ Подписка на заказы конкретного tenant _/
export function subscribeOrders(tenantId: string, onChange: (c: OrderChange) => void) {
const supabase = createSupabaseAnon()
const channelName = `orders:tenant:${tenantId}`

const ch: RealtimeChannel = supabase
.channel(channelName)
.on('postgres_changes',
{ event: '\*', schema: 'public', table: 'orders', filter: `tenant_id=eq.${tenantId}` },
(payload) => onChange({ type: payload.eventType as OrderChange['type'], new: payload.new, old: payload.old })
)
.subscribe((status) => {
// optional: status handling 'SUBSCRIBED' | 'CLOSED' | 'CHANNEL_ERROR'
})

return () => supabase.removeChannel(ch)
}

ENV (проверь .env.example):

NEXT_PUBLIC_SUPABASE_URL=...
NEXT_PUBLIC_SUPABASE_ANON_KEY=...

S-01.6.d — Демо-страница

apps/web/app/realtime-demo/page.tsx:

'use client'
import { useEffect, useState } from 'react'
import { subscribeOrders } from '@lib/realtime/orders'

export default function Page() {
const [events, setEvents] = useState<any[]>([])
const tenantId = typeof window !== 'undefined' ? localStorage.getItem('\_\_demo_tenant') ?? '' : ''

useEffect(() => {
if (!tenantId) return
const off = subscribeOrders(tenantId, (c) => setEvents((e) => [c, ...e].slice(0, 20)))
return off
}, [tenantId])

return (
<div className="p-6 space-y-3">
<h1 className="text-lg font-semibold">Realtime Orders ({tenantId || '—'})</h1>
<input
className="border rounded px-2 py-1 text-sm"
placeholder="tenant-uuid"
defaultValue={tenantId}
onBlur={(e) => localStorage.setItem('\_\_demo_tenant', e.target.value)}
/>
<pre className="text-xs overflow-auto max-h-[50vh] border rounded p-3 bg-black text-white">
{JSON.stringify(events, null, 2)}
</pre>
</div>
)
}

S-01.6.e — Смоки 1. Подписка: открой /realtime-demo, укажи tenant_id из сидов. 2. Вставка: выполните один из вариантов:
• Через SQL:

insert into public.orders (tenant_id, site_id, status, subtotal_cents, total_cents, currency)
values ('<TENANT_UUID>', '<EXISTING_SITE_ID>', 'pending', 1200, 1200, 'USD');

    •	Через seed-скрипт/консоль приложений (POST на ваш handler, если уже есть).

    3.	Ожидание: на странице появляется событие INSERT с new записью.
    4.	Негатив: подпишитесь на tenant_id другого клиента и повторите вставку — событие не приходит.

S-01.6.f — Документация

/docs/notes/realtime-channels.md:
• Идея именования каналов: orders:tenant:<uuid> (чтобы удобно дебажить).
• Конфиг публикации и причина REPLICA IDENTITY FULL.
• Фильтрация filter: tenant_id=eq.<uuid>.
• RLS влияет на доставку — чужие строки недоступны.
• Траблшутинг: проверить публикацию/политики/индекс/ключи ENV.

⸻

Примечания
• Realtime-подключение использует анонимный ключ клиента; убедись, что пользователь аутентифицирован Supabase Auth, иначе RLS может скрыть строки вашего tenant.
• Для UPDATE/DELETE события полезно REPLICA IDENTITY FULL, иначе old может быть пустым.
• Дальше (S-05.x) добавим fallback (SSE→polling) и интеграцию в дашборд.
