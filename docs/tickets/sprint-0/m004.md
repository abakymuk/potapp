S-01.4 — Storage Buckets

Goal: создать два бакета site-assets (public, ограниченная запись) и backoffice (private); политики доступа по tenant_id и роли.
AC: загрузка изображения меню проходит только в свой tenant_id, чужой — отклоняется.

⸻

Scope
• In: создание бакетов, helper-функции для извлечения tenant_id из пути объекта, RLS-политики на storage.objects для SELECT/INSERT/UPDATE/DELETE. Клиентская конвенция пути:
"{tenant_id}/menus/{menu_id}/{filename}"
• Out: генерация подписанных URL, CDN cache, валидация MIME/размера (отдельные тикеты).

⸻

AC (Gherkin)
• Given пользователь — член tenant T1 (роль manager+)
When он делает PUT в site-assets по пути T1/menus/<menu>/img.jpg
Then загрузка успешна (201) и объект виден по публичной ссылке.
• Given тот же пользователь
When он делает PUT в site-assets по пути T2/menus/<menu>/img.jpg (чужой tenant)
Then запрос отклонён (403) политикой RLS.
• Given backoffice (private)
When сделать GET без подписанного URL
Then доступ запрещён (401/403).

⸻

DoD
• Бакеты site-assets (public) и backoffice (private) созданы
• Добавлена app.path_tenant(name text) -> uuid
• Политики на storage.objects:
• site-assets: read public, write/update/delete только can_write(tenant)
• backoffice: read/write только члены tenant (viewer = read)
• Клиентская конвенция путей задокументирована
• Смоки: успешная загрузка в свой tenant и отказ в чужой
• /docs/notes/storage.md описывает схему и примеры

⸻

Микротикеты (атомарные шаги)

S-01.4.a — Создать бакеты

Любой из вариантов: SQL через редактор или RPC storage.create_bucket.

SQL (идемпотентно):

insert into storage.buckets (id, name, public)
values ('site-assets','site-assets', true)
on conflict (id) do nothing;

insert into storage.buckets (id, name, public)
values ('backoffice','backoffice', false)
on conflict (id) do nothing;

site-assets — публичный чтением (CDN), запись ограничим RLS.
backoffice — полностью приватный; чтение через signed URLs (позже).

⸻

S-01.4.b — Helper для извлечения tenant из пути

create schema if not exists app;

create or replace function app.path_tenant(object_name text)
returns uuid
language plpgsql
immutable
as $$
declare
  first_seg text := split_part(object_name, '/', 1);
  tid uuid;
begin
  begin
    tid := first_seg::uuid;
  exception when others then
    return null;
  end;
  return tid;
end $$;

Путь должен начинаться с UUID тенанта:
{tenant_id}/menus/{menu_id}/{filename}

⸻

S-01.4.c — Политики для site-assets (public)

-- Чтение: публичное. Для public bucket это по сути доступ по URL;
-- но оставим SELECT метаданных всем (или сузьте по желанию).
create policy site_assets_select on storage.objects
for select
using (bucket_id = 'site-assets');

-- Запись: только участники tenant с правом write (owner/admin/manager)
create policy site_assets_insert on storage.objects
for insert
to authenticated
with check (
bucket_id = 'site-assets'
and app.can_write(app.path_tenant(name))
);

-- Обновление/удаление: только write
create policy site_assets_update on storage.objects
for update
to authenticated
using (
bucket_id = 'site-assets'
and app.can_write(app.path_tenant(name))
)
with check (
bucket_id = 'site-assets'
and app.can_write(app.path_tenant(name))
);

create policy site_assets_delete on storage.objects
for delete
to authenticated
using (
bucket_id = 'site-assets'
and app.can_write(app.path_tenant(name))
);

⸻

S-01.4.d — Политики для backoffice (private)

-- Чтение: только члены tenant (viewer+)
create policy backoffice_select on storage.objects
for select
to authenticated
using (
bucket_id = 'backoffice'
and app.is_member(app.path_tenant(name))
);

-- Запись: только write (owner/admin/manager)
create policy backoffice_insert on storage.objects
for insert
to authenticated
with check (
bucket_id = 'backoffice'
and app.can_write(app.path_tenant(name))
);

-- Обновление/удаление: только write
create policy backoffice_update on storage.objects
for update
to authenticated
using (
bucket_id = 'backoffice'
and app.can_write(app.path_tenant(name))
)
with check (
bucket_id = 'backoffice'
and app.can_write(app.path_tenant(name))
);

create policy backoffice_delete on storage.objects
for delete
to authenticated
using (
bucket_id = 'backoffice'
and app.can_write(app.path_tenant(name))
);

Политики опираются на функции S-01.3: app.is_member, app.can_write. Убедись, что они уже применены.

⸻

S-01.4.e — Клиентская конвенция путей
• site-assets (public):
/${tenant_id}/menus/${menu_id}/${fileName}
Пример: b8a1f3d7-.../menus/7b2.../margherita.jpg
	•	backoffice (private):
/${tenant_id}/reports/${yyyy}/${mm}/${fileName}.csv

На стороне клиента запрещено писать пути с чужим tenant_id. Библиотеку загрузки обернуть в helper, который подставляет текущий tenant_id из сессии.

⸻

S-01.4.f — Смоки (curl/HTTP)

Успешная загрузка в свой tenant (замени переменные):

# токен аутентифицированного пользователя tenant T1

AUTH="Bearer <access_token_of_T1_member>"
TENANT="b8a1f3d7-...."
FILE="@./margherita.jpg"

curl -i \
 -H "Authorization: $AUTH" \
  -H "Content-Type: image/jpeg" \
  --data-binary $FILE \
  "${SUPABASE_URL}/storage/v1/object/site-assets/${TENANT}/menus/7b2.../margherita.jpg"

# Ожидание: 200/201 Created

Попытка загрузить в чужой tenant:

curl -i \
 -H "Authorization: $AUTH" \
  -H "Content-Type: image/jpeg" \
  --data-binary $FILE \
  "${SUPABASE_URL}/storage/v1/object/site-assets/<OTHER_TENANT_UUID>/menus/x/img.jpg"

# Ожидание: 403 Forbidden (RLS)

Чтение public объекта (без auth):

GET ${SUPABASE_URL}/storage/v1/object/public/site-assets/${TENANT}/menus/.../margherita.jpg

⸻

S-01.4.g — Документация

/docs/notes/storage.md:
• Бакеты: site-assets (public), backoffice (private)
• Схема путей и причины (RLS по префиксу tenant)
• Примеры загрузок (client SDK / REST)
• Безопасность: никогда не принимать путь из пользовательского ввода без проверки; tenant_id берём из сессии.

⸻

Примечания
• В public бакете нельзя «частично» ограничить чтение на уровне URL — он публичный по дизайну. Ограничиваем только запись/изменение. Для приватного доступа используйте подписанные URL (отдельный тикет).
• Если нужен более строгий контроль листинга метаданных, сузьте SELECT для site-assets до anon запрета (оставив публичным только CDN-чтение).
• Для валидации форматов/размеров используйте allowed_mime_types/file_size_limit при создании бакета (можно добавить дополнительно).
