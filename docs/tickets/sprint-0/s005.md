S-00.5 — Feature Flags (PostHog FF)

Goal: утилита ff.isEnabled('key') для web (Next.js) и worker (Cloudflare), единый DX.
Scope:
	•	In: PostHog SDK (web), edge/worker-совместимый серверный резолвер флагов (Decide API), кэш на короткий TTL, демо-страница с условным UI.
	•	Out: эксперименты/метрики экспериментов (будет в Analytics спринте), сложные таргетинги групп.

⸻

AC (Gherkin)
	•	Given создан фичфлаг new_checkout_flow в PostHog
When пользователь открывает /ff-demo
Then отображается вариант UI согласно состоянию флага.
	•	Given Cloudflare Worker эндпоинт /healthz расширен проверкой флага
When вызываю его с distinct_id
Then ответ содержит feature: enabled|disabled в соответствии с флагом.
	•	Given недоступен PostHog
When происходит резолв флага
Then используется безопасный дефолт (disabled) и пишется warning-лог (без падения).

DoD
	•	packages/lib/ff с API isEnabled(ctx, key, props?) и унифицированным типом контекста
	•	Реализация: web (posthog-js) и server/worker (Decide API, fetch) + небольшой TTL-кэш
	•	Переменные окружения добавлены (web/worker)
	•	Демо-страница apps/web/app/ff-demo/page.tsx + кнопка принудительного refetch
	•	Пример в worker: GET /ff-demo?key=...&distinct_id=...
	•	Документация /docs/notes/feature-flags.md
	•	pnpm lint / pnpm typecheck / pnpm build зелёные

⸻

Микротикеты (атомарные шаги)

S-00.5.a — Зависимости и env

Root:

pnpm -w add posthog-js

Для server/worker используем HTTP Decide API через fetch (без дополнительных SDK — совместимо с Edge/Workers).

.env.example (root):

# Web
NEXT_PUBLIC_POSTHOG_KEY=phc_xxx
NEXT_PUBLIC_POSTHOG_HOST=https://us.i.posthog.com
# Worker / server (если нужен иной хост — используем тот же)
POSTHOG_PROJECT_API_KEY=phc_xxx
POSTHOG_HOST=https://us.i.posthog.com
FF_DECIDE_TTL_MS=60000


⸻

S-00.5.b — Утилита packages/lib/ff

packages/lib/src/ff/types.ts

export type FFContext =
  | { kind: 'web'; distinctId: string; personProps?: Record<string, unknown>; groups?: Record<string, string> }
  | { kind: 'worker'; distinctId: string; personProps?: Record<string, unknown>; groups?: Record<string, string>; host?: string; apiKey?: string };

export type FFResult = { key: string; enabled: boolean; variant?: string | null; source: 'cache' | 'posthog' | 'client' | 'fallback' };

packages/lib/src/ff/decide.ts — сервер/воркер:

let decideCache = new Map<string, { until: number; value: boolean; variant?: string | null }>()

const now = () => Date.now()
const ttl = Number(process.env.FF_DECIDE_TTL_MS || 60000)

type DecideResp = { featureFlags?: Record<string, boolean | string>; }

export async function decideIsEnabled(
  host: string,
  apiKey: string,
  distinctId: string,
  key: string,
  personProps?: Record<string, unknown>,
  groups?: Record<string, string>
) {
  const ck = `${host}:${key}:${distinctId}`
  const hit = decideCache.get(ck)
  if (hit && hit.until > now()) return { key, enabled: !!hit.value, variant: hit.variant ?? null, source: 'cache' as const }

  const url = `${host.replace(/\/$/, '')}/decide/`
  const body = {
    token: apiKey, // project API key
    distinct_id: distinctId,
    groups,
    person_properties: personProps,
    // Примечание: можно добавить 'v' для версии флагов/вариантов.
  }
  try {
    const res = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) })
    if (!res.ok) throw new Error(`Decide ${res.status}`)
    const json = (await res.json()) as DecideResp
    const value = json.featureFlags?.[key]
    const enabled = typeof value === 'string' ? true : !!value
    const variant = typeof value === 'string' ? value : null
    decideCache.set(ck, { until: now() + ttl, value: enabled, variant })
    return { key, enabled, variant, source: 'posthog' as const }
  } catch {
    return { key, enabled: false, variant: null, source: 'fallback' as const }
  }
}

packages/lib/src/ff/web.ts — клиент (Next.js):

import posthog from 'posthog-js'
import type { FFResult } from './types'

let initialized = false
export function initWebPosthog() {
  if (initialized) return
  const key = process.env.NEXT_PUBLIC_POSTHOG_KEY!
  const host = process.env.NEXT_PUBLIC_POSTHOG_HOST || 'https://us.i.posthog.com'
  if (!key) return
  posthog.init(key, { api_host: host, autocapture: false })
  initialized = true
}

export async function webIsEnabled(key: string, distinctId: string): Promise<FFResult> {
  initWebPosthog()
  if (!distinctId) return { key, enabled: false, variant: null, source: 'fallback' }
  posthog.identify(distinctId)
  // posthog-js синхронно/асинхронно подтянет флаги; ждём актуализацию:
  await posthog.reloadFeatureFlagsAsync?.()
  const variant = (posthog.getFeatureFlag?.(key) as string | boolean | undefined) ?? false
  const enabled = typeof variant === 'string' ? true : !!variant
  return { key, enabled, variant: typeof variant === 'string' ? variant : null, source: 'client' }
}

packages/lib/src/ff/index.ts — единая фасад-функция:

import { decideIsEnabled } from './decide'
import { webIsEnabled } from './web'
import type { FFContext, FFResult } from './types'

export async function isEnabled(ctx: FFContext, key: string): Promise<FFResult> {
  if (ctx.kind === 'web') {
    return webIsEnabled(key, ctx.distinctId)
  }
  const host = ctx.host || process.env.POSTHOG_HOST || 'https://us.i.posthog.com'
  const apiKey = ctx.apiKey || process.env.POSTHOG_PROJECT_API_KEY!
  return decideIsEnabled(host, apiKey, ctx.distinctId, key, ctx.personProps, ctx.groups)
}

Безопасность: на клиенте используется public project key; на сервере/воркере — тот же project key, не персональный API ключ.

⸻

S-00.5.c — Демо-страница (Next.js)

apps/web/app/ff-demo/page.tsx (RSC + небольшой client-компонент):

// app/ff-demo/page.tsx
import Client from './client'

export default function Page() {
  // distinctId для демо: из cookies/anon id (в реале — user.id)
  return <Client />
}

apps/web/app/ff-demo/client.tsx

'use client'
import { useEffect, useState } from 'react'
import { isEnabled } from '@lib/ff' // экспортируй через index.ts пакета
import { v4 as uuid } from 'uuid'

const KEY = 'new_checkout_flow'

function getDistinctId(): string {
  const k = '__demo_distinct_id'
  let id = localStorage.getItem(k)
  if (!id) { id = uuid(); localStorage.setItem(k, id) }
  return id
}

export default function Client() {
  const [state, setState] = useState<{loading:boolean; enabled:boolean; variant?:string|null; source?:string}>({loading:true, enabled:false})
  useEffect(() => {
    const did = getDistinctId()
    isEnabled({ kind: 'web', distinctId: did }, KEY).then(r => setState({ loading:false, enabled:r.enabled, variant:r.variant, source:r.source }))
  }, [])
  if (state.loading) return <div className="p-6 text-sm opacity-70">Checking feature flag…</div>
  return (
    <div className="p-6 space-y-4">
      <div className="text-xs opacity-70">flag: <b>{KEY}</b> | source: {state.source} | variant: {state.variant ?? '—'}</div>
      {state.enabled ? (
        <div className="rounded-xl border p-6">✅ <b>New Checkout</b> is ENABLED — показываем новый поток</div>
      ) : (
        <div className="rounded-xl border p-6">⬜ Old Checkout — флаг выключен</div>
      )}
      <button className="rounded-lg border px-3 py-1 text-sm" onClick={() => location.reload()}>
        Refetch
      </button>
    </div>
  )
}


⸻

S-00.5.d — Пример в Cloudflare Worker

apps/worker/src/routes/ff-demo.ts

import { isEnabled } from '@lib/ff'

export default async function ffDemo(req: Request, env: any) {
  const url = new URL(req.url)
  const key = url.searchParams.get('key') || 'new_checkout_flow'
  const distinctId = url.searchParams.get('distinct_id') || 'anon-worker'
  const res = await isEnabled(
    { kind: 'worker', distinctId, host: env.POSTHOG_HOST, apiKey: env.POSTHOG_PROJECT_API_KEY },
    key
  )
  return new Response(JSON.stringify(res), { headers: { 'Content-Type': 'application/json' } })
}

wrangler.toml (фрагмент):

[vars]
POSTHOG_HOST = "https://us.i.posthog.com"
POSTHOG_PROJECT_API_KEY = "phc_xxx"


⸻

S-00.5.e — Smoke-тест
	1.	Создай фичфлаг new_checkout_flow в PostHog (release globally / 50%).
	2.	Локально: pnpm dev → открой /ff-demo, убедись, что UI меняется при переключении флага в PostHog (возможно нужен reload).
	3.	Worker: wrangler dev → GET /ff-demo?distinct_id=tester возвращает JSON с enabled: true|false.
	4.	Отключи интернет/подмени host → убедись, что вернётся enabled:false с source:'fallback'.

⸻

S-00.5.f — Документация

/docs/notes/feature-flags.md:

# Feature Flags (PostHog)
- Веб: posthog-js, identify(distinctId), reloadFeatureFlagsAsync
- Сервер/Worker: Decide API через fetch, TTL кэш (env FF_DECIDE_TTL_MS)
- Env: NEXT_PUBLIC_POSTHOG_KEY, NEXT_PUBLIC_POSTHOG_HOST, POSTHOG_PROJECT_API_KEY, POSTHOG_HOST
- Безопасный дефолт: disabled + warning
- Использование:
  import { isEnabled } from '@lib/ff'
  const r = await isEnabled({ kind: 'worker', distinctId }, 'new_checkout_flow')


⸻

Примечания
	•	Для устойчивых экспериментов используй один и тот же distinctId (userId/anon cookie).
	•	Кэш TTL держи небольшим (30–60 c), чтобы флип флага быстро доходил до продакшена.
	•	PII не отправляем в PostHog без необходимости — достаточно distinctId и минимальных props.
	•	В будущем можно добавить: групповые флаги (tenant_id), экспозицию событий в PostHog Experiments, и server-side bucketing через подписанные cookies.